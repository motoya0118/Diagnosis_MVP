from __future__ import annotations

import argparse
import json
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Any

import yaml


@dataclass(frozen=True)
class ErrorEntry:
    enum_name: str
    domain: str
    name: str
    code: str
    http_status: int
    message: str

    @property
    def enum_value(self) -> str:
        return self.code


def load_yaml(path: Path) -> dict[str, Any]:
    try:
        with path.open("r", encoding="utf-8") as fp:
            data = yaml.safe_load(fp)
    except FileNotFoundError as exc:
        raise SystemExit(f"error: YAML not found: {path}") from exc
    except yaml.YAMLError as exc:
        raise SystemExit(f"error: failed to parse YAML {path}: {exc}") from exc

    if not isinstance(data, dict):
        raise SystemExit("error: YAML root must be a mapping")
    return data


def normalize_code(prefix: str, code: str) -> str:
    return f"{prefix}{code}"


def to_enum_name(domain: str, name: str) -> str:
    cleaned = domain.replace("-", "_").replace("/", "_")
    return f"{cleaned.upper()}_{name.upper()}"


def collect_entries(raw: dict[str, Any]) -> list[ErrorEntry]:
    domains = raw.get("domains")
    if not isinstance(domains, dict):
        raise SystemExit("error: `domains` must be a mapping")

    entries: list[ErrorEntry] = []
    seen_codes: dict[str, str] = {}

    for domain, payload in sorted(domains.items()):
        if not isinstance(payload, dict):
            raise SystemExit(f"error: domain `{domain}` must be a mapping")
        prefix = payload.get("prefix")
        if not isinstance(prefix, str):
            raise SystemExit(f"error: domain `{domain}` requires string `prefix`")
        errors = payload.get("errors")
        if not isinstance(errors, dict):
            raise SystemExit(f"error: domain `{domain}` requires mapping `errors`")
        for name, meta in sorted(errors.items()):
            if not isinstance(meta, dict):
                raise SystemExit(f"error: error `{domain}.{name}` must map to a dict")
            code = meta.get("code")
            http_status = meta.get("http")
            message = meta.get("message")
            if not isinstance(code, str):
                raise SystemExit(f"error: `{domain}.{name}` missing string `code`")
            if not isinstance(http_status, int):
                raise SystemExit(f"error: `{domain}.{name}` missing integer `http`")
            if not isinstance(message, str):
                raise SystemExit(f"error: `{domain}.{name}` missing string `message`")
            full_code = normalize_code(prefix, code)
            enum_name = to_enum_name(domain, name)
            if full_code in seen_codes:
                raise SystemExit(
                    f"error: duplicated error code `{full_code}` for `{seen_codes[full_code]}` and `{enum_name}`"
                )
            seen_codes[full_code] = enum_name
            entries.append(
                ErrorEntry(
                    enum_name=enum_name,
                    domain=domain,
                    name=name,
                    code=full_code,
                    http_status=http_status,
                    message=message,
                )
            )

    entries.sort(key=lambda entry: (entry.code, entry.enum_name))
    return entries


def dumps(value: Any) -> str:
    return json.dumps(value, ensure_ascii=False)


def render(entries: list[ErrorEntry]) -> str:
    lines: list[str] = []
    lines.append("# Code generated by scripts/generate_error_codes.py. DO NOT EDIT.")
    lines.append("from __future__ import annotations")
    lines.append("")
    lines.append("from dataclasses import dataclass")
    lines.append("from enum import Enum")
    lines.append("from typing import Final")
    lines.append("")
    lines.append("")
    lines.append("@dataclass(frozen=True)")
    lines.append("class ErrorDefinition:")
    lines.append("    \"\"\"Static metadata for an application error code.\"\"\"")
    lines.append("    code: str")
    lines.append("    domain: str")
    lines.append("    name: str")
    lines.append("    http_status: int")
    lines.append("    message: str")
    lines.append("")
    lines.append("")
    lines.append("class ErrorCode(str, Enum):")
    lines.append("    \"\"\"Enumerates all application error codes.\"\"\"")
    for entry in entries:
        lines.append(f"    {entry.enum_name} = {dumps(entry.code)}")
    lines.append("")
    lines.append("    def definition(self) -> ErrorDefinition:")
    lines.append("        return ERROR_DEFINITIONS[self]")
    lines.append("")
    lines.append("    @property")
    lines.append("    def http_status(self) -> int:")
    lines.append("        return self.definition().http_status")
    lines.append("")
    lines.append("    @property")
    lines.append("    def message(self) -> str:")
    lines.append("        return self.definition().message")
    lines.append("")
    lines.append("    @property")
    lines.append("    def domain(self) -> str:")
    lines.append("        return self.definition().domain")
    lines.append("")
    lines.append("    @property")
    lines.append("    def label(self) -> str:")
    lines.append("        return self.definition().name")
    lines.append("")
    lines.append("    @classmethod")
    lines.append("    def from_code(cls, code: str) -> \"ErrorCode\":")
    lines.append("        try:")
    lines.append("            return _ERROR_BY_VALUE[code]")
    lines.append("        except KeyError as exc:")
    lines.append("            raise ValueError(f'Unknown error code: {code}') from exc")
    lines.append("")
    lines.append("")
    lines.append("ERROR_DEFINITIONS: Final[dict[ErrorCode, ErrorDefinition]] = {")
    for entry in entries:
        lines.append(
            f"    ErrorCode.{entry.enum_name}: ErrorDefinition("
            f"code={dumps(entry.code)}, "
            f"domain={dumps(entry.domain)}, "
            f"name={dumps(entry.name)}, "
            f"http_status={entry.http_status}, "
            f"message={dumps(entry.message)}),"
        )
    lines.append("}")
    lines.append("")
    lines.append("_ERROR_BY_VALUE: Final[dict[str, ErrorCode]] = {code.value: code for code in ErrorCode}")
    lines.append("")
    return "\n".join(lines) + "\n"


def write_output(path: Path, content: str, *, check: bool) -> int:
    if check:
        if not path.exists():
            print(f"error: generated file missing: {path}", file=sys.stderr)
            return 1
        existing = path.read_text(encoding="utf-8")
        if existing != content:
            print(f"error: {path} is out of date", file=sys.stderr)
            return 1
        return 0

    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(content, encoding="utf-8")
    return 0


def parse_args() -> argparse.Namespace:
    root = Path(__file__).resolve().parents[1]
    default_yaml = root / "error_codes.yaml"
    default_output = root / "app" / "core" / "errors.py"

    parser = argparse.ArgumentParser(description="Generate backend error code definitions")
    parser.add_argument("--yaml", dest="yaml_path", type=Path, default=default_yaml, help="Path to error_codes.yaml")
    parser.add_argument("--output", dest="output_path", type=Path, default=default_output, help="Output python file path")
    parser.add_argument("--check", action="store_true", help="Only check that the output file is up to date")
    return parser.parse_args()


def main() -> int:
    args = parse_args()
    raw = load_yaml(args.yaml_path)
    entries = collect_entries(raw)
    content = render(entries)
    return write_output(args.output_path, content, check=args.check)


if __name__ == "__main__":
    sys.exit(main())
