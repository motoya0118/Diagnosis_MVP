# 3. 共通診断画面設計

## ページ概要
- Path: `/diagnostics/common_qa`
- 目的: 任意の診断コードに対する質問票を表示し、回答データをローカルに保持しつつ送信する。
- 想定遷移元: `/diagnostics/{diagnostic_code}` 。

## 初期化フロー
1. URLクエリ `diagnostic_code` を取得（未指定の場合は404画面へ遷移）。
2. ローカルストレージに保持している診断ステートを読み込む。`status=completed` かつ `session_code` を保持している場合は、共通診断画面で「前回の結果を表示する / 再診断する」確認ダイアログを表示し、この時点では新規セッションを発行しない。`status=awaiting_llm` は回答送信済みで結果生成待ち中の状態を表し、この場合は自動再送信を避けるため既存セッションの復元を優先する。
3. 再診断が選択された場合のみ `20_user_start_session` API（`POST /diagnostics/{code}/sessions`）を呼び出し `session_code`・`version_id` を取得する。選択が維持される場合は既存セッション情報を継続利用する。
4. `21_user_get_form` API（`GET /diagnostics/versions/{version_id}/form`）を呼び出し、質問リスト・選択肢リストを受領。
5. ローカルストレージに診断ステートを初期化。

- 手順 2〜4 の API 呼び出し中は `LoaderOverlay` を表示し、画面全体を非アクティブ化する。初期表示は「診断内容を読み込んでいます...」、既存セッションからの再診断選択時は「再診断の準備をしています...」をメッセージとして提示する。

```json
{
  "diagnostic_code": "ai_career",
  "version_id": 123,
  "session_code": "ULID...",
  "choices": {
    "Q01": [1001],
    "Q02": [1004, 1005]
  },
  "status": "in_progress" // or "awaiting_llm" / "completed"
}
```

- 既存データが存在する場合は復元し、バージョン/セッションが異なる場合は新規セッションを再発行する。

## UI構成
- ヘッダー: 診断名、現在の質問番号、進捗バー。
- 質問コンテンツ
  - 質問文、説明文（あれば）、選択肢リスト。
  - `multi` が 1 の場合はチェックボックス、0 の場合はラジオボタン。
  - 選択肢に補足テキストがある場合は折りたたみ表示。
- ナビゲーションボタン
  - `前へ`/`次へ` ボタン。
  - 最終質問時は `回答を送信` ボタンを表示し、最後の設問で少なくとも1つ選択肢が選ばれるまで非アクティブ（disabled）にする。

## 操作ロジック
- 選択肢クリック時に `choices` を即時更新しローカルストレージへ同期。
- `前へ` ボタン押下時は一つ前の質問に戻り、戻った質問の未選択状態を維持。
- `multi=0` で再選択した場合は既存配列を置き換える。
- 戻る操作で質問をスキップした場合は、該当 `q_code` の配列を削除する。
- 完了済みセッションを保持した状態で遷移してきた場合は、結果表示または再診断の選択ダイアログを表示し、再診断選択時にのみ新しいセッションを発行する。

## ローディング挙動
- `LoaderOverlay` は画面全体を覆う固定レイヤーで、`aria-live="polite"` / `role="status"` を持つメッセージとスピナーを表示する。フェードイン・アウトは 200ms、最小表示時間は 300ms とする。
- オーバーレイ表示中は `document.body` のスクロールをロックし、フォーカスはローダーに委譲する。処理完了後に元のスクロール状態へ復元する。
- API 切り替えごとに文言を更新する。
  - 初期化（`start_session`/`get_form`）: 「診断内容を読み込んでいます...」
  - 再診断フロー: 「再診断の準備をしています...」
  - 回答送信（`22_user_submit_answer`）: 「回答を送信しています...」
  - LLM 実行（`23_user_call_llm`）: 「結果を生成しています（Amazon Bedrock）...」
- エラー発生時はローダーを即時解除し、既存のエラー表示へ遷移する。再試行が押されると再びローダーを表示する。

## 回答送信
- 最終設問の選択肢が1つ以上選択されている場合のみ `回答を送信` ボタンをアクティブにする。
1. `回答を送信` 押下で未回答がないかチェック。
2. `choices` から選択肢IDの配列を抽出し、`22_user_submit_answer` API（`POST /sessions/{session_code}/answers`）を呼び出す。サーバ側で `version_options_hash` が計算・保存される。
3. 続けて `23_user_call_llm` API（`POST /sessions/{session_code}/llm`、`force_regenerate=false`）を呼び出し、`sessions.llm_result` を確定させておく。レスポンス（`llm_result` と `messages`）は画面状態およびローカルストレージに保存し、結果画面に引き継げるようにする。
4. LLM 実行開始までは `status` を `awaiting_llm` とし（`version_options_hash` を保持）、成功レスポンスを受け取ったタイミングで `status=completed`・`completed_at` を保存する。
5. `/diagnostics/{diagnostic_code}/result?session_code=...` へ遷移する。この時点で LLM は実行済みのため、結果画面は保存済み `llm_result` を参照して描画する。

- API エラー時はダイアログで再試行可とする。

## エラー・例外処理
- API呼び出し失敗時はリトライボタン付きのエラーステートを表示。
- `session_code` が期限切れの場合は再度セッション開始APIを叩いて再連携。
- ローカルストレージ書き込み不可（Safariプライベートモード等）の場合はメモリ保持にフォールバックし警告を出す。

## テスト観点
- 単一選択/複数選択の分岐。
- 戻る操作時に回答が正しく削除されるか。
- 送信後のリダイレクトURLに `session_code` が付与されるか。
- ストレージ破損時のリカバリー挙動。
- 完了済みセッション復元時に確認ダイアログが表示され正しい分岐（結果表示 / 再診断）が行えるか。
- 最終設問が未回答の間は `回答を送信` ボタンが非アクティブであるか。
- 各ローディング状態で `LoaderOverlay` が適切な文言とともに表示/解除され、操作がブロックされるか。
