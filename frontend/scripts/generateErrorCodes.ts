import { promises as fs } from "fs";
import path from "path";
import YAML from "yaml";

type RawError = {
  code: string;
  ui_message: string;
  action?: string | null;
};

type RawDomain = {
  prefix: string;
  errors: Record<string, RawError>;
};

type RawYaml = {
  version: number;
  domains: Record<string, RawDomain>;
};

interface ErrorEntry {
  code: string;
  domain: string;
  name: string;
  uiMessage: string;
  action: string | null;
}

type EntryList = ErrorEntry[];

function computeCode(prefix: string, code: string): string {
  return `${prefix}${code}`;
}

async function loadYaml(filePath: string): Promise<RawYaml> {
  const content = await fs.readFile(filePath, "utf-8");
  const parsed = YAML.parse(content) as RawYaml;
  if (!parsed || typeof parsed !== "object" || !parsed.domains) {
    throw new Error("Invalid error_codes.yaml structure");
  }
  return parsed;
}

function collectEntries(raw: RawYaml): EntryList {
  const entries: EntryList = [];
  const seen = new Map<string, string>();

  for (const [domain, payload] of Object.entries(raw.domains)) {
    if (!payload || typeof payload.prefix !== "string") {
      throw new Error(`Domain ${domain} is missing prefix`);
    }
    for (const [name, meta] of Object.entries(payload.errors ?? {})) {
      const fullCode = computeCode(payload.prefix, meta.code);
      if (seen.has(fullCode)) {
        throw new Error(`Duplicate error code ${fullCode} for ${name}`);
      }
      seen.set(fullCode, name);
      entries.push({
        code: fullCode,
        domain,
        name,
        uiMessage: meta.ui_message,
        action: meta.action ?? null,
      });
    }
  }

  entries.sort((a, b) => (a.code === b.code ? a.name.localeCompare(b.name) : a.code.localeCompare(b.code)));
  return entries;
}

function formatString(value: string): string {
  return JSON.stringify(value);
}

function render(entries: EntryList): string {
  const lines: string[] = [];
  lines.push("/* eslint-disable */");
  lines.push("// Code generated by scripts/generateErrorCodes.ts. DO NOT EDIT.");
  lines.push("// Run `npm run generate:error-codes` after editing error_codes.yaml.");
  lines.push("");
  lines.push("export interface ErrorCodeDefinition {");
  lines.push("  code: string;");
  lines.push("  domain: string;");
  lines.push("  name: string;");
  lines.push("  uiMessage: string;");
  lines.push("  action: string | null;");
  lines.push("}");
  lines.push("");
  lines.push("export const ERROR_DEFINITIONS = {");
  for (const entry of entries) {
    lines.push(
      `  ${formatString(entry.code)}: { code: ${formatString(entry.code)}, domain: ${formatString(entry.domain)}, name: ${formatString(entry.name)}, uiMessage: ${formatString(entry.uiMessage)}, action: ${entry.action ? formatString(entry.action) : "null"} },`
    );
  }
  lines.push("} as const satisfies Record<string, ErrorCodeDefinition>;");
  lines.push("");
  lines.push("export type ErrorCodeValue = keyof typeof ERROR_DEFINITIONS;");
  lines.push("");
  lines.push("export const ERROR_CODE_LIST: readonly ErrorCodeDefinition[] = Object.values(ERROR_DEFINITIONS);");
  lines.push("");
  lines.push("export function getErrorDefinition(code: string): ErrorCodeDefinition | undefined {");
  lines.push("  return ERROR_DEFINITIONS[code as ErrorCodeValue];");
  lines.push("}");
  lines.push("");
  lines.push("export function requireErrorDefinition(code: string): ErrorCodeDefinition {");
  lines.push("  const found = getErrorDefinition(code);");
  lines.push("  if (!found) {");
  lines.push("    throw new Error(`Unknown error code: ${code}`);");
  lines.push("  }");
  lines.push("  return found;");
  lines.push("}");
  lines.push("");
  lines.push("export function isErrorWithCode(value: unknown): value is { error: { code: string } } {");
  lines.push("  if (!value || typeof value !== 'object') return false;");
  lines.push("  const error = (value as any).error;");
  lines.push("  return !!error && typeof error === 'object' && typeof error.code === 'string';");
  lines.push("}");
  lines.push("");
  lines.push("export function resolveUiError(code: string): { uiMessage: string; action: string | null } | undefined {");
  lines.push("  const def = getErrorDefinition(code);");
  lines.push("  if (!def) return undefined;");
  lines.push("  return { uiMessage: def.uiMessage, action: def.action };");
  lines.push("}");
  lines.push("");
  return `${lines.join("\n")}\n`;
}

async function main() {
  const projectRoot = process.cwd();
  const yamlPath = path.join(projectRoot, "error_codes.yaml");
  const outputPath = path.join(projectRoot, "lib", "error-codes.ts");

  const raw = await loadYaml(yamlPath);
  const entries = collectEntries(raw);
  const content = render(entries);
  await fs.mkdir(path.dirname(outputPath), { recursive: true });
  await fs.writeFile(outputPath, content, "utf-8");
}

main().catch((error) => {
  console.error("Failed to generate error codes", error);
  process.exit(1);
});
